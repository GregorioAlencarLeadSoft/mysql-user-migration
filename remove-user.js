const { createPool } = require('./config/database');
const { getMigrationTables } = require('./config/tables');
const chalk = require('chalk');
const fs = require('fs');
require('dotenv').config();

/**
 * Classe para remo√ß√£o segura de usu√°rio ap√≥s migra√ß√£o
 */
class UserRemover {
    constructor() {
        this.pool = createPool();
        this.sourceUserId = parseInt(process.env.SOURCE_USER_ID) || 41;
        this.dryRun = process.env.DRY_RUN === 'true';
        this.removalLog = [];
        this.migrationTables = getMigrationTables();
    }

    /**
     * Adiciona entrada ao log de remo√ß√£o
     */
    log(level, message, data = null) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level,
            message,
            data
        };
        this.removalLog.push(logEntry);
        
        const colorMap = {
            info: chalk.blue,
            success: chalk.green,
            warning: chalk.yellow,
            error: chalk.red
        };
        
        console.log(colorMap[level] || chalk.white, `[${level.toUpperCase()}] ${message}`);
        if (data) {
            console.log(chalk.gray('  Data:'), data);
        }
    }

    /**
     * Salva o log de remo√ß√£o em arquivo
     */
    saveRemovalLog() {
        const logFile = `removal-log-${Date.now()}.json`;
        fs.writeFileSync(logFile, JSON.stringify({
            sourceUserId: this.sourceUserId,
            dryRun: this.dryRun,
            migrationTables: this.migrationTables,
            timestamp: new Date().toISOString(),
            log: this.removalLog
        }, null, 2));
        this.log('info', `Log de remo√ß√£o salvo em: ${logFile}`);
        return logFile;
    }

    /**
     * Verifica se √© seguro remover o usu√°rio
     */
    async verifySafeToRemove() {
        try {
            this.log('info', 'Verificando se √© seguro remover o usu√°rio...');
            
            const safetyCheck = {};
            let totalReferences = 0;
            
            // Verificar cada tabela especificada para refer√™ncias restantes
            for (const tableConfig of this.migrationTables) {
                const tableName = tableConfig.table;
                const userIdColumn = tableConfig.column;
                
                try {
                    const [countResult] = await this.pool.execute(
                        `SELECT COUNT(*) as count FROM \`${tableName}\` WHERE \`${userIdColumn}\` = ?`,
                        [this.sourceUserId]
                    );
                    
                    const count = countResult[0].count;
                    safetyCheck[tableName] = {
                        column: userIdColumn,
                        remainingReferences: count
                    };
                    
                    totalReferences += count;
                    
                    if (count > 0) {
                        this.log('warning', `Tabela ${tableName}: ${count} refer√™ncias restantes na coluna ${userIdColumn}`);
                    } else {
                        this.log('info', `Tabela ${tableName}: Nenhuma refer√™ncia restante`);
                    }
                } catch (error) {
                    this.log('error', `Erro ao verificar tabela ${tableName}`, error.message);
                    safetyCheck[tableName] = {
                        column: userIdColumn,
                        remainingReferences: -1,
                        error: error.message
                    };
                }
            }
            
            const isSafe = totalReferences === 0;
            
            if (isSafe) {
                this.log('success', 'Verifica√ß√£o conclu√≠da: √â seguro remover o usu√°rio');
            } else {
                this.log('error', `Verifica√ß√£o falhou: ${totalReferences} refer√™ncias restantes encontradas`);
            }
            
            return {
                isSafe,
                totalReferences,
                safetyCheck
            };
            
        } catch (error) {
            this.log('error', 'Erro na verifica√ß√£o de seguran√ßa', error.message);
            throw error;
        }
    }

    /**
     * Cria backup do usu√°rio antes da remo√ß√£o
     */
    async createUserBackup() {
        try {
            this.log('info', 'Criando backup do usu√°rio...');
            
            // Buscar dados do usu√°rio na tabela principal
            const [userData] = await this.pool.execute(
                'SELECT * FROM user WHERE id = ?',
                [this.sourceUserId]
            );
            
            if (userData.length === 0) {
                throw new Error(`Usu√°rio ${this.sourceUserId} n√£o encontrado para backup`);
            }
            
            const user = userData[0];
            const backupData = {
                timestamp: new Date().toISOString(),
                userId: this.sourceUserId,
                userData: user,
                backupReason: 'Pre-deletion backup',
                migrationTables: this.migrationTables
            };
            
            const backupFile = `user-backup-${this.sourceUserId}-${Date.now()}.json`;
            fs.writeFileSync(backupFile, JSON.stringify(backupData, null, 2));
            
            this.log('success', `Backup do usu√°rio criado: ${backupFile}`, {
                userName: user.name || user.email,
                backupFile
            });
            
            return backupFile;
            
        } catch (error) {
            this.log('error', 'Erro ao criar backup', error.message);
            throw error;
        }
    }

    /**
     * Remove o usu√°rio da tabela principal
     */
    async removeUserRecord() {
        try {
            this.log('info', `Removendo usu√°rio ${this.sourceUserId} da tabela user...`);
            
            if (this.dryRun) {
                this.log('warning', 'DRY RUN: Simulando remo√ß√£o do usu√°rio');
                return { removed: false, simulated: true };
            }
            
            const [deleteResult] = await this.pool.execute(
                'DELETE FROM user WHERE id = ?',
                [this.sourceUserId]
            );
            
            if (deleteResult.affectedRows === 0) {
                throw new Error(`Nenhum usu√°rio encontrado com ID ${this.sourceUserId}`);
            }
            
            this.log('success', `Usu√°rio ${this.sourceUserId} removido com sucesso`);
            
            return { 
                removed: true, 
                affectedRows: deleteResult.affectedRows 
            };
            
        } catch (error) {
            this.log('error', 'Erro ao remover usu√°rio', error.message);
            throw error;
        }
    }

    /**
     * Verifica se a remo√ß√£o foi bem-sucedida
     */
    async verifyRemoval() {
        try {
            this.log('info', 'Verificando se a remo√ß√£o foi bem-sucedida...');
            
            const [userCheck] = await this.pool.execute(
                'SELECT COUNT(*) as count FROM user WHERE id = ?',
                [this.sourceUserId]
            );
            
            const userExists = userCheck[0].count > 0;
            
            if (userExists) {
                this.log('error', `Usu√°rio ${this.sourceUserId} ainda existe na tabela user`);
                return { success: false, userStillExists: true };
            } else {
                this.log('success', `Confirmado: Usu√°rio ${this.sourceUserId} foi removido com sucesso`);
                return { success: true, userStillExists: false };
            }
            
        } catch (error) {
            this.log('error', 'Erro na verifica√ß√£o de remo√ß√£o', error.message);
            throw error;
        }
    }

    /**
     * Executa processo completo de remo√ß√£o segura
     */
    async run() {
        let connection;
        try {
            console.log(chalk.red.bold('üóëÔ∏è  INICIANDO REMO√á√ÉO SEGURA DE USU√ÅRIO\n'));
            
            // Verificar se √© seguro remover
            const safetyResult = await this.verifySafeToRemove();
            
            if (!safetyResult.isSafe) {
                throw new Error(`N√£o √© seguro remover o usu√°rio. ${safetyResult.totalReferences} refer√™ncias restantes encontradas.`);
            }
            
            // Criar backup
            const backupFile = await this.createUserBackup();
            
            // Iniciar transa√ß√£o para remo√ß√£o
            connection = await this.pool.getConnection();
            if (!this.dryRun) {
                await connection.beginTransaction();
                this.log('info', 'Transa√ß√£o de remo√ß√£o iniciada');
            }
            
            // Remover usu√°rio
            const removalResult = await this.removeUserRecord();
            
            // Verificar remo√ß√£o
            const verificationResult = await this.verifyRemoval();
            
            if (!this.dryRun && verificationResult.success) {
                await connection.commit();
                this.log('success', 'Transa√ß√£o de remo√ß√£o confirmada');
            } else if (!this.dryRun) {
                await connection.rollback();
                this.log('error', 'Transa√ß√£o de remo√ß√£o revertida devido √† falha na verifica√ß√£o');
            }
            
            const logFile = this.saveRemovalLog();
            
            console.log(chalk.green.bold('\n‚úÖ REMO√á√ÉO CONCLU√çDA COM SUCESSO!'));
            console.log(chalk.white(`üë§ Usu√°rio removido: ${this.sourceUserId}`));
            console.log(chalk.white(`üíæ Backup salvo em: ${backupFile}`));
            console.log(chalk.white(`üìã Log salvo em: ${logFile}`));
            
            return {
                safety: safetyResult,
                backup: backupFile,
                removal: removalResult,
                verification: verificationResult,
                logFile
            };
            
        } catch (error) {
            this.log('error', 'Falha na remo√ß√£o', error.message);
            if (connection && !this.dryRun) {
                try {
                    await connection.rollback();
                    this.log('info', 'Transa√ß√£o revertida devido ao erro');
                } catch (rollbackError) {
                    this.log('error', 'Erro ao reverter transa√ß√£o', rollbackError.message);
                }
            }
            this.saveRemovalLog();
            throw error;
        } finally {
            if (connection) {
                connection.release();
            }
            await this.pool.end();
        }
    }
}

// Executar remo√ß√£o se chamado diretamente
if (require.main === module) {
    const remover = new UserRemover();
    remover.run()
        .then(() => {
            console.log(chalk.green.bold('\nüéâ Processo de remo√ß√£o finalizado!'));
            process.exit(0);
        })
        .catch((error) => {
            console.error(chalk.red.bold('\nüí• Falha no processo de remo√ß√£o:'), error.message);
            process.exit(1);
        });
}

module.exports = UserRemover;